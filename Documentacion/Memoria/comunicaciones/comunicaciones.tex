
\newpage

\chapter{Comunicaciones}
\label{chap:robot}


En el presente capítulo comenzaremos con una introducción sobre el funcionamiento y los fundamentos teóricos sobre cómo se gestionan las diferentes conexiones y eventos de cualquier aplicación
Sails para, posteriormente, centrarnos específicamente en la descripción de un caso práctico desarrollado en el presente proyecto con la finalidad de comprender mejor su funcionamiento y poder afianzar
conocimientos.


\subsection{Introduccion}
\label{sec:fundamentos}

En esta sección se comenzaremos destacando aquellos aspectos teóricos sobre cómo Sails, framework Node JS utilizado en el desarrollo, trabaja con websocket y socket.io.\\

Como sabemos, un servidor http no puede enviar datos a menos que un cliente los haya solicitado mediante una petición. Los Websockets, en cambio, presentan la particularidad de que
permiten que un servidor envíe datos a un cliente sin la necesidad de que éstos sean solicitados, al menos de una manera inmediata. Estas solicitudes, realizadas con anterioridad, se formalizan mediante suscripciones, concepto que 
iremos constantemente haciendo referencia a lo largo del presente capítulo y que debemos recordar.\\


\begin{figure}%
    \centering
    \includegraphics[width=7cm]{diagramas/http-weboscket.png}
    \qquad
    \includegraphics[width=7cm]{diagramas/http+weboscket.png}
    \caption{Peticiones entre un navegador y un servidor http con y sin el empleo de websockets.}%
    \label{fig:http-request}%
\end{figure}

Anteriormente comentamos que el servidor http no puede enviar datos a menos que el cliente lo haya solicitado y los Websockets permiten que un servidor envíe datos no solicitados una vez que se hace 
una conexión inicial (suscripción) desde el lado del cliente. Una aplicación Sails típica queda dividida en dos partes. La primera, en el lado del servidor, consta de un servidor http junto con un nodo
central que actúa como un servidor de sockets.\\ 

En segundo lugar, en el lado del cliente, se dispone de los diferentes códigos html y funciones JavaScript para realizar las conexiones con el servidor. Estas conexiones cliente-servidor permiten que 
cualquier otro cliente conectado pueda enviar mensajes al servidor para que a su vez éstos sean emitidos a los clientes que se encuentren conectados en la aplicación en ese instante.\\

Además cada socket posee un identificador único que identifica de manera inequívoca el cliente o, en nuestro, caso el navegador que está accediendo a la página.\\

Destacar también el concepto de salas o rooms de Socket.io. Las salas nos permite agrupar los sockets de modo que en lugar de mensajes que son enviados a todos los sockets conectados, se puede enviar mensajes
sólo a los sockets que están asociados con una sala. De esta podremos mandar mensajes específicos para un cliente concreto, todos ellos o un conjunto de los mismos. \\


\begin{figure}[H]
  \begin{center}
    \includegraphics[scale=0.35]{diagramas/salas-websocket.png}
  \end{center}
  \caption{Representación de una sala compuesta por dos clientes.}
  \label{view:userindex}
\end{figure}


De todo los anterior podemos deducir que Sails es un framework especialmente potente, el cual proporciona infinidad de posibilidades a desarrollar. A continuación se cita un fragmento tal y 
como podemos extraer de la página oficial de Sails:\\

\begin{center}
\emph{Sails.js facilita el desarrollo de aplicaciones Node.js empresariales. Ha sido diseñado para imitar el patrón MVC de frameworks como Ruby on Rails, pero con soporte para los requisitos de aplicaciones modernas: data-driven APIs con una arquitectura escalable y service-oriented. Es especialmente bueno para el desarrollo de chats, cuadros de mando en tiempo real o juegos multijugadores.} 
\end{center}


En este caso menciona diferentes aplicaciones tipo que pueden desarrollarse con Sails, desde un chat, cuadros de mando en tiempo real o juegos multijugadores. RobotUI resulta como una combinación de las 
anteriores puesto que incorpora cuadros de mandos, sistema de mensajería y también es considerado como un juego ya que también está enfocado al entretenimiento.\\





\subsection{ Comunicaciones en RobotUI }
\label{sec:comunicaciones-robotui}



Tras la comprensión de los fundamentos teóricos descritos en el punto \ref{sec:fundamentos} donde se recogen los fundamentos del framework y sabiendo cómo trabaja y gestiona los sockets pasamos
a trasladarlos a un caso práctico describiendo una de las funcionalidades del proyecto de tal manera que se facilite su comprensión.\\

Como sabemos, Sails nos ayuda a incorporar funcionalidades en tiempo real a nuestra aplicación web. Sails gestiona los eventos aplicándolos sobre los modelos. Comenzamos realizando una descripción
del ejemplo a desarrollar.\\

Centrémonos en el modelo \emph{Usuario} de RobotUI. Uno de los atributos de este modelo es un booleano \emph{online}, el cual representa si un usuario se encuentra logueado en el sistema o no. El objetivo 
es saber cuando el usuario cambia el estado para poder proporcionar una actualización en tiempo real de la página de gestión de usuarios \ref{view:userindex} de manera que cuando usuario inicie sesión o salga de la 
aplicación se alterne entre las imágenes online: \icontext{.2}{.35}{imagenes/comunicaciones/online.png} y offline: \icontext{.2}{.35}{imagenes/comunicaciones/offline.png} sin necesidad de refrescar la página manualmente.\\

\begin{figure}[H]
  \begin{center}
    \includegraphics[scale=0.35]{imagenes/comunicaciones/index-usuarios.png}
  \end{center}
  \caption{Página de gestión de usuarios actualizable en tiempo real.}
  \label{view:userindex}
\end{figure}

Para capturar los eventos correspondientes al modelo \emph{Usuario} o cualquier otro debemos realizar una suscripción. Sails incorpora dos modalidades de suscripción. suscripción a clase y 
suscripción a modelo.\\

¿Cuál es la diferencia entre suscribirse a una ``clase'' frente a la suscripción a una ``instancia''? Al suscribirse a la ``clase'' del modelo, el socket podrá escuchar la creación de 
nuevas instancias de modelo mediante un método denominado publishCreate(). Mientras que la suscripción a ``instancia'' permite al socket escuchar los cambios de modelos
a través de los métodos publishUpdate y/o publishDestroy de una instancia o conjunto de instancias en concreto.\\


Por tanto, centrándonos en el ejemplo de los usuarios, debemos realizar la suscripción mediante la definición de una acción en el controlador de usuario. La acción se denominará \emph{user\_subscribe}.\\

En dicha acción podremos acceder al socket solicitante vía req.socket. Así que, primeramente se realiza una suscripción a la sala de ``clase'' del usuario mediante User.watch y pasando 
req.socket como argumento. De esta manera nos hemos suscrito a la clase del modelo de usuario.\\

Seguidamente se realiza la suscripción a las instancias del modelo de usuario mediante el método User.subscribe pasando como parámetro el socket solicitante obtenido a través de req.socket seguido
de un segundo argumento, que son las instancias existentes de usuarios. Las instancias de los usuarios existentes son recuperadas mediante un método de búsqueda para que, posteriormente, su salida 
sea pasada al método de suscripción como segundo argumento. Con esto ya nos hemos suscrito a las salas de instancias del modelo de usuario.\\

A continuación mostramos el código que realiza la suscripción al modelo Usuario en sus dos modalidades, suscripción a modelo y suscripción a instancias de modelo descrito anteriormente:

\begin{lstlisting}[language=JavaScript]

  user_subscribe: function (req, res, next) {
    if (req.isSocket) {
      //Update, destroy...
      User.find(function foundUsers(err, users) {
        if (err) return res.badRequest(err);

        User.subscribe(req.socket, users);
      });

      //Create
      User.watch(req);
      console.log('User ' + req.session.User.id + 'with socket id ' + sails.sockets.id(req) + ' is now subscribed to the model class \'User\'.');
    } else {
      res.view();
    }
  }
  
\end{lstlisting}

Ahora bien, ya nos encontramos suscritos a un modelo, pero... ¿Qué ocurre con publishCreate, publishUpdate y publishDestroy?, ¿Dónde se realiza la llamada a estos métodos?\\


Para ello solamente debemos llamar al método en la acción deseada, por ejemplo, al crear una sessión, tan solo debemos actualizar el usuario como online y mandar el mensaje correspondiente mediante
el método publishUpdate:\\

\begin{lstlisting}[language=JavaScript]

        //Cambio de estado a online
        User.update(user.id, {online: true, longitude: long, latitude: lat}, function (err){
          if (err) return next(err);

          //Informar a otros clientes (sockets abiertos) que el usuario esta logueado
          User.publishUpdate(user.id, {
            loggedIn: true,
            id: user.id
          });
         });

\end{lstlisting}


Del mismo modo para publishCreate o publishDestroy.\\


¿Y desde el lado del cliente? ¿Cómo realizamos las llamadas a las diferentes acciones de suscripción y cómo capturamos los eventos?\\


Las siguientes funciones resultan de vital importancia:\\

\begin{lstlisting}[language=JavaScript]


<script type="text/javascript">

  $.when(savesocket()).done(function(){
    if (typeof subscribeAndListen == 'function') {
      subscribeAndListen();
    }
    listenMessages();
  });

  //Funcion para tener en to do momento almacenado en la tabla session los sockets conectados junto con el usuario al que pertenece
  function savesocket() {
    io.socket.get("/session/saveSocketID");
  }
</script>

\end{lstlisting}


Primeramente tenemos la función \emph{savesocket} la cual realiza la llamada al método saveSocketID del controlador \emph{session}. Dicho método realiza el registro en base de datos ligando el identificador del 
socket abierto con el usuario al que corresponde, de tal manera que siempre sabremos qué socket corresponde con qué usuario.

\begin{lstlisting}[language=JavaScript]


  //Almacenamiento en la base de datos la sesion de cada usuario de la pagina
  saveSocketID: function(req, res) {
    if (!req.isSocket) return res.badRequest();

    var socketId = sails.sockets.id(req);
    // => "BetX2G-2889Bg22xi-jy"

    var sessionObj = {
      socket_id: socketId,
      user_id: req.session.User != undefined ? req.session.User.id : null
    };

    Session.create(sessionObj).exec( function (err, session) {
      if (err) return res.badRequest();

      console.log('\n....................................................');
      console.log('Conectando a Sails js...');
      console.log('Cliente conectado - id del socket: ' + socketId);
      console.log('....................................................');

      return;
    });
  }
  
\end{lstlisting}

Una vez tenemos almacenado el par socket-usuario buscamos la función subscribeAndListen, la cual será específica según la vista en la que nos encontremos, por ejemplo, si nos encontramos en el panel
de administración de usuarios, la función subscribeAndListen será específica para 


\begin{lstlisting}[language=JavaScript]


<script type="text/javascript">

  function subscribeAndListen() {
    io.socket.get('/user/user_subscribe');

    io.socket.on('user', function (obj) {
      if (obj.verb == 'created') {
        var user = obj.data;
        $.ajax({
          url: '/user/render',
          type: 'GET',
          data: {id: user.id},
          success: function(data){
            $("#user_list").append(data);
           toastr.info('<%= i18n('user_created')%>', 'RobotUI' )
          }
        });
      }

      if (obj.verb == 'updated') {
        var data = obj.data;
        change_img_state(data.id, data.loggedIn, '<%= i18n('connect')%>', '<%= i18n('disconnect')%>');

        if (data.id != '<%= req.session.User.id %>') {
          if (data.loggedIn) {
           toastr.info('<%= i18n('user_connected')%>', 'RobotUI');
          } else {
           toastr.info('<%= i18n('user_disconnected')%>', 'RobotUI');
          }
          console.log('User has been updated to online:' + data.loggedIn);
        }
      }

      if (obj.verb == 'destroyed') {
        $("#user_" + obj.id).remove();
       toastr.info('<%= i18n('user_destroyed') %>', 'RobotUI' );
      }

    });

  }

</script>

\end{lstlisting}





\begin{figure}[H]
  \begin{center}
    \includegraphics[scale=0.5]{diagramas/flujo-comunicaciones.png}
  \end{center}
  \caption{Esquema representativo del flujo de conexiones de RobotUI.}
  \label{diagram:conexiones}
\end{figure}

\subsubsection{ Conexión }
\label{sec:conexion}


Cuando se realiza una una conexión de un usuario al sistema, un nuevo cliente, realiza una petición al servidor, el cual captura la llamada y renderiza la vista correspondiente elaborando una respuesta.\\

Dicha respuesta se corresponde con el cógido Html y JavaScript que recibe el navegador. En el archivo \emph{views/layout.js} se encuentra el siguiente código JavaScript de gran importancia
para el funcionamiento de toda la aplicación por lo que resulta interesante su comprensión.\\

Primeramente al realizarse una nueva conexión de un cliente en el sistema el servidor debe conocer y registrar a dicho cliente con la finalidad de seguir su comportamiento, sus acciones y 
movimientos por toda la aplicación.\\

\begin{lstlisting}[language=JavaScript]
  \/\/Funcion para tener en todo momento almacenado en la tabla session los sockets conectados junto con el usuario al que pertenece
  function savesocket() {
    io.socket.get("/session/saveSocketID");
  }  
\end{lstlisting}


Función que realiza el registro de un nuevo cliente en la base de datos:\\

\begin{lstlisting}[language=JavaScript]


  //Almacenamiento en la base de datos la sesion de cada usuario de la pagina
  saveSocketID: function(req, res) {
    if (!req.isSocket) return res.badRequest();

    var socketId = sails.sockets.id(req);
    // => "BetX2G-2889Bg22xi-jy"

    var sessionObj = {
      socket_id: socketId,
      user_id: req.session.User != undefined ? req.session.User.id : null
    };

    Session.create(sessionObj).exec( function (err, session) {
      if (err) return res.badRequest();

      console.log('\n....................................................');
      console.log('Conectando a Sails js...');
      console.log('Cliente conectado - id del socket: ' + socketId);
      console.log('....................................................');

      return;
    });
  },

\end{lstlisting}

Una vez finaliza el registro en el servidor del nuevo cliente se comprueba si existe definida la función \emph{ subscribeAndListen } llamándose en caso afirmativo. Dicha función es específica para cada
funcionalidad que queramos inicializar o a qué eventos nos deseemos suscribir. Por ejemplo, suscribirnos a los eventos de conexión y desconexión de usuarios del panel de administración descrito en el apartado
\ref{sec:fundamentos} mediante la definición de la función \emph{subscribeAndListen} en la vista correspondiente.\\


Por otro lado, siempre se realiza la llamada a la función \emph{listenMessages} ya que independientemente de la vista en la que nos encontremos siempre nos mantendremos a la escucha de los mensajes 
recibidos a nuestra bandeja de entrada por parte de otros usuarios.\\

Finalmente mostramos el código JavaScript al completo localizado en el archivo \emph{views/layout.js}:\\


\begin{lstlisting}[language=JavaScript]

<script type="text/javascript">

  $.when(savesocket()).done(function(){
    if (typeof subscribeAndListen == 'function') {
      subscribeAndListen();
    }
    listenMessages();
  });

  //Funcion para tener en todo momento almacenado en la tabla session los sockets conectados junto con el usuario al que pertenece
  function savesocket() {
    io.socket.get("/session/saveSocketID");
  }

</script>
 
\end{lstlisting} 
 
\subsubsection { Desconexión }
\label{sec:deconexion}

En este apartado describiremos los puntos de mayor relevancia a la hora de la desconexión de alguna de las diferentes comunicaciones establecidas comenzando con la desconexión de un usuario.\\

Cuando un usuario realiza una desconexión, bien deslogueándose de la página o cerrando una de las ventanas abiertas, automáticamente se lanza una llamada a la 
función \emph{afterDisconnect} localizada en el fichero \emph{config/Socket.js} del servidor. Función que será ejecutada cada vez que un socket es desconectado del sistema.\\

Dicha función primeramente localiza qué sesión en la base de relacionada está relacionada con identificador del socket desconectado. Si este socked estaba usando algún robot, éste se libera cambiando el estado
del robot a \emph{libre}. Y se informa a todos los sockets abiertos que el robot queda libreado y accesible al resto de usuarios.\\

\begin{lstlisting}[language=JavaScript]
  Robot.update({id: session.robot_id}, {busy: false}, function robotUpdated(err) {
    if (err) return next(err);

    //Informar a otros clientes (sockets abiertos) que el robot queda liberado
    Robot.publishUpdate(session.robot_id, {
      busy: false,
      id: session.robot_id
    });
  });
\end{lstlisting}


A continuación, se comprueba si el usuario no dispone de más sockets abiertos. Si fuera el caso de que no los disponga, entonces se procede a cambiar su estado a desconectado y se emite o se informa al resto de clientes (sockets abiertos)
que el usuario ya no se encuentra en el sistema. Llamada al método \emph{User.publishUpdate}: \\

\begin{lstlisting}[language=JavaScript]
   User.publishUpdate(session.user_id, {
    loggedIn: false,
    id: session.user_id
  });
\end{lstlisting}


Se comprueba si el usuario desconectado se encontraba en alguna \emph{room}. Pongamos como ejemplo que el usuario ha abandonado la visualización de un robot por lo queda
se debe informar a todos los sockets integrantes de esa \emph{room} que un usuario la ha abandonado con la función \emph{ sails.sockets.broadcast }. A continuación se muestra el fragmento de código:\\


\begin{lstlisting}[language=JavaScript]

//Emite a cada room que que se encuentre la sesión que un usuario la ha abandonado

session.rooms.forEach(function (room) {
  //sails.sockets.leave(session.socket_id, room.room_name, function(err) {
  //  if (err) {return res.serverError(err);}
  //});
  sails.sockets.broadcast(room.room_name, {type: 'exit', msg: {user_id: session.user_id}});
});

\end{lstlisting}



Finalmente se destruye la sesión:\\

\begin{lstlisting}[language=JavaScript]
    Session.destroy(session.id, function sessionDestroyed(err) {
      if (err) return cb();
      return cb();
    });
\end{lstlisting}


A continuación mostramos el código completo de la función \emph{afterDisconnect}:\\


\begin{lstlisting}[language=JavaScript]

  afterDisconnect: function(session, socket, cb) {
     console.log('Cliente desconectado - id del socket: ' + socket.id);

    //Session del socket cerrado,
    Session.findOne({socket_id: socket.id}).populate('rooms').exec(function (err, session) {
      if (err) return cb();
      if (!session) return cb();

      //Comprobar si el soscket estaba usando algun robot para liberarlo:
      if (session.robot_id) {
        console.log('Socked was using a robot');

        Robot.update({id: session.robot_id}, {busy: false}, function robotUpdated(err) {
          if (err) return next(err);

          //Informar a otros clientes (sockets abiertos) que el robot queda liberado
          Robot.publishUpdate(session.robot_id, {
            busy: false,
            id: session.robot_id
          });
        });
      }


      //Emite a cada room que que se encuentre la sesión que un usuario la ha abandonado ->  
      session.rooms.forEach(function (room) {
        //sails.sockets.leave(session.socket_id, room.room_name, function(err) {
        //  if (err) {return res.serverError(err);}
        //});
        sails.sockets.broadcast(room.room_name, {type: 'exit', msg: {user_id: session.user_id}});
      });


      //Comprobar si el usuario tiene más sockets abiertos:
      Session.count({user_id: session.user_id}).exec(function countUserSessions(error, n_sessions) {
        console.log('There are ' + n_sessions + ' users ' + session.user_id);

        //Cambiamos el usuario a offline si solo tenía una ventana o conexión abierta.
        if (n_sessions == 1) {
          User.update(session.user_id, {online: false}, function (err) {
            if (err) return cb(err);

            //Informar a otros clientes (sockets abiertos) que el usuario ya NO se encuentra logueado
            User.publishUpdate(session.user_id, {
              loggedIn: false,
              id: session.user_id
            });
          });
        }

        Session.destroy(session.id, function sessionDestroyed(err) {
          if (err) return cb();
          return cb();
        });
      });
    });
  }

\end{lstlisting}
 